#!/usr/bin/env python3
import cv2
import glob
import numpy as np
from scipy.spatial.transform import Rotation as R
from scipy.io import loadmat


class Camera():
    def __init__(self):
        self.rotation = R.from_rotvec(np.zeros(3))
        self.distortion = np.zeros(5)
        self.skew = 0
        self.t = np.zeros(3)
        self.k = np.zeros((3, 3))
        self.calibration_files = []

    @property
    def r(self):
        """return rotational matrix of the camera"""
        return self.rotation.as_dcm()

    @property
    def f(self):
        """focal lengths of the camera"""
        return [self.k[0, 0], self.k[1, 1]]

    @property
    def c(self):
        """principal point of the camera"""
        return [self.k[0, 2], self.k[1, 2]]


    @property
    def p(self):
        self.ext = np.hstack([self.r, np.array([self.t]).T])  # R, t --> [R|t]
        return np.dot(self.k, self.ext)


    def read_calibration(self, mat_file):
        """
        Read calibration result from TOOLBOX_calib
        The calibration result is generated by following Matlab script:
            save(filename, 'fc', 'cc', 'Tc_ext', 'Rc_ext');
        """
        calib_result = loadmat(mat_file)
        self.k[0][0] = calib_result['fc'][0, 0]
        self.k[1][1] = calib_result['fc'][1, 0]
        self.k[0][2] = calib_result['cc'][0, 0]
        self.k[1][2] = calib_result['cc'][1, 0]
        self.distortion = [0, 0, 0, 0, 0]
        self.t = calib_result['Tc_ext'][:, 0]
        self.rotation = R.from_dcm(calib_result['Rc_ext'])

    def project(self, position):
        """
        project a 3D position onto the image plane
        """
        assert position.shape == (3,), "Please input an [x, y, z] array"
        pos_homo = np.hstack([position, 1])
        pos_homo = np.expand_dims(pos_homo, 1)
        pos_uv = np.squeeze(self.p @ pos_homo)
        pos_uv /= pos_uv[-1]
        return pos_uv

    def undistort(self, image):
        pass

    def calibrate(self, int_images: list, ext_image: str, grid_size: float, corner_number=(6, 6), win_size=(5, 5)):
        """
        update intrinsic and extrinsic camera matrix using opencv's chessboard detector
        the distortion coefficients are also being detected
        """
        # termination criteria
        criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 30, 0.001)

        # prepare object points, like (0,0,0), (1,0,0), (2,0,0) ....,(6,5,0)
        obj_points_single = np.zeros((corner_number * corner_number, 3), np.float32)
        obj_points_single[:, :2] = np.mgrid[0:corner_number[0], 0:corner_number[1]].T.reshape(-1, 2) * grid_size  # unit mm

        # Arrays to store object points and image points from all the images.
        obj_points = [] # 3d point in real world space
        img_points = [] # 2d points in image plane.

        image_files = int_images + [ext_image]

        for i, fname in enumerate(image_files):
            img = cv2.imread(fname)
            gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

            # Find the chess board corners
            ret, corners = cv2.findChessboardCorners(gray, corner_number, None)

            if ret == True:
                obj_points.append(obj_points_single)
                corners_refined = cv2.cornerSubPix(gray, corners, win_size, (-1,-1), criteria)
                img_points.append(corners_refined)
                img = cv2.drawChessboardCorners(img, (6, 6), corners2, ret)
                cv2.imshow('img', img)
                cv2.waitKey(500)

        obj_points = np.array(obj_points)
        img_points = np.array(img_points)

        ret, camera_matrix, distortion, rvecs, tvecs = cv2.calibrateCamera(
                obj_points, img_points, gray.shape[::-1], None, None
        )

        # get matrices for undistorted image
        camera_matrix, roi = cv2.getOptimalNewCameraMatrix(
        camera_matrix, distortion, gray.shape, 1, gray.shape
        )


        self.k = camera_matrix
        self.distortion = np.squeeze(distortion)
        self.rotation = R.from_rotvec(rvecs)
        self.tvecs = np.ravel(tvecs)
